"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LedgerWallet = void 0;
/* eslint-disable @typescript-eslint/no-non-null-assertion */
const hw_app_trx_1 = __importDefault(require("@ledgerhq/hw-app-trx"));
const hw_transport_webhid_1 = __importDefault(require("@ledgerhq/hw-transport-webhid"));
const openModal_js_1 = require("./Modal/openModal.js");
function wait(timeout) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => {
            setTimeout(resolve, timeout);
        });
    });
}
function isFunction(fn) {
    return typeof fn === 'function';
}
const defaultSelectAccount = function ({ accounts, ledgerUtils }) {
    return __awaiter(this, void 0, void 0, function* () {
        const account = yield (0, openModal_js_1.openSelectAccountModal)({
            accounts,
            getAccounts: ledgerUtils.getAccounts,
        });
        const closeConfirm = (0, openModal_js_1.openVerifyAddressModal)(account.address);
        try {
            yield ledgerUtils.getAddress(account.index, true);
        }
        finally {
            closeConfirm === null || closeConfirm === void 0 ? void 0 : closeConfirm();
        }
        return account;
    });
};
class LedgerWallet {
    constructor(config = {}) {
        this.app = null;
        this.transport = null;
        this.fetchState = 'Initial';
        this.selectedIndex = 0;
        this._address = '';
        this.getAccounts = (from, to) => __awaiter(this, void 0, void 0, function* () {
            if (from < 0) {
                throw new Error('getAccount parameter error: from cannot be smaller than 0.');
            }
            if (from >= to) {
                throw new Error('getAccount parameter error: from cannot be bigger than to.');
            }
            if (this.fetchState === 'Fetching') {
                yield wait(500);
                return this.getAccounts(from, to);
            }
            this.fetchState = 'Fetching';
            // ledger can not get address concurrently.
            yield this.makeApp();
            try {
                const obj = {};
                for (let i = from; i < to; i++) {
                    const account = yield this.getAccount(i);
                    obj[account.index] = account;
                }
                Object.keys(obj).forEach((key) => {
                    this.accounts[+key] = obj[key];
                });
                return this.accounts.slice(from, to);
            }
            finally {
                this.fetchState = 'Initial';
                yield this.cleanUp();
            }
        });
        this.getAddress = (index, display = false) => __awaiter(this, void 0, void 0, function* () {
            try {
                const path = this.getPathForIndex(index);
                yield this.makeApp();
                return yield this.app.getAddress(path, display);
            }
            finally {
                yield this.cleanUp();
            }
        });
        this.accounts = [];
        const { accountNumber = 1 } = config;
        ['beforeConnect', 'selectAccount', 'getDerivationPath'].forEach((func) => {
            if (config[func] && !isFunction(config[func])) {
                throw new Error(`[Ledger]: ${func} must be a function!`);
            }
        });
        if (accountNumber && !Number.isInteger(+accountNumber)) {
            throw new Error('[Ledger]: accountNumber must be an integer!');
        }
        this.config = Object.assign(Object.assign({}, config), { accountNumber });
    }
    get address() {
        return this._address;
    }
    connect(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((options === null || options === void 0 ? void 0 : options.account) && typeof options.account === 'object') {
                const account = options.account;
                this.selectedIndex = +account.index;
                this._address = account.address;
                if (account.index === undefined || account.address === undefined) {
                    console.warn('[LedgerWallet] account parameter passed to connect() should have valid index and address property');
                }
                return;
            }
            const ledgerUtils = {
                getAccounts: this.getAccounts,
                getAddress: this.getAddress,
            };
            this.accounts = [];
            this._address = '';
            this.selectedIndex = 0;
            const { accountNumber = 1, beforeConnect, selectAccount = defaultSelectAccount } = this.config;
            let closeConnectingModal = null;
            try {
                if (beforeConnect) {
                    yield beforeConnect();
                }
                else {
                    closeConnectingModal = (0, openModal_js_1.openConnectingModal)();
                }
                yield this.makeApp();
                const firstAccount = yield this.getAccount(0);
                this.accounts[0] = firstAccount;
                yield this.cleanUp();
                if (accountNumber > 1) {
                    yield this.getAccounts(1, accountNumber);
                }
                closeConnectingModal === null || closeConnectingModal === void 0 ? void 0 : closeConnectingModal();
                const accounts = this.accounts.slice(0, accountNumber);
                const selectedAccount = yield selectAccount({
                    accounts,
                    ledgerUtils,
                });
                this.selectedIndex = selectedAccount.index;
                this._address = selectedAccount.address;
            }
            finally {
                yield this.cleanUp();
            }
        });
    }
    disconnect() {
        this.selectedIndex = 0;
        this._address = '';
    }
    signPersonalMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.waitForIdle();
            try {
                const index = this.selectedIndex;
                yield this.makeApp();
                const path = this.getPathForIndex(index);
                const hex = Buffer.from(message).toString('hex');
                const res = yield this.app.signPersonalMessage(path, hex);
                return res;
            }
            finally {
                yield this.cleanUp();
            }
        });
    }
    signTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.waitForIdle();
            try {
                const index = this.selectedIndex;
                const path = this.getPathForIndex(index);
                yield this.makeApp();
                let signedResponse;
                try {
                    signedResponse = yield this.app.signTransaction(path, transaction.raw_data_hex, []);
                }
                catch (e) {
                    if (/Too many bytes to encode/.test(e.message)) {
                        signedResponse = yield this.app.signTransactionHash(path, transaction.txID);
                    }
                    else {
                        throw e;
                    }
                }
                if (Array.isArray(transaction.signature)) {
                    if (!transaction.signature.includes(signedResponse))
                        transaction.signature.push(signedResponse);
                }
                else {
                    transaction.signature = [signedResponse];
                }
                return transaction;
            }
            finally {
                yield this.cleanUp();
            }
        });
    }
    getAccount(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = this.getPathForIndex(index);
            const { address } = yield this.app.getAddress(path);
            return {
                path,
                address,
                index,
            };
        });
    }
    waitForIdle() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.fetchState === 'Fetching') {
                yield wait(300);
                yield this.waitForIdle();
            }
        });
    }
    getPathForIndex(index) {
        return this.config.getDerivationPath ? this.config.getDerivationPath(index) : `44'/195'/${index}'/0/0`;
    }
    makeApp() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.transport && this.app) {
                return;
            }
            this.transport = yield hw_transport_webhid_1.default.create();
            this.app = new hw_app_trx_1.default(this.transport);
        });
    }
    cleanUp() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.app = null;
            yield ((_a = this.transport) === null || _a === void 0 ? void 0 : _a.close());
            this.transport = null;
        });
    }
}
exports.LedgerWallet = LedgerWallet;
//# sourceMappingURL=LedgerWallet.js.map